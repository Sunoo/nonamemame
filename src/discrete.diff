*** raw/drivers/canyon.c	Sat Mar  6 15:45:26 2004
--- src/drivers/canyon.c	Tue Mar  9 01:53:06 2004
***************
*** 450,456 ****
  	DISCRETE_GAIN(CANYON_FINAL_MIX1, NODE_90, 77)
  	DISCRETE_GAIN(CANYON_FINAL_MIX2, NODE_91, 77)
  
! 	DISCRETE_OUTPUT_STEREO(CANYON_FINAL_MIX1, CANYON_FINAL_MIX2, 100)
  DISCRETE_SOUND_END
  
  
--- 450,457 ----
  	DISCRETE_GAIN(CANYON_FINAL_MIX1, NODE_90, 77)
  	DISCRETE_GAIN(CANYON_FINAL_MIX2, NODE_91, 77)
  
! 	DISCRETE_OUTPUT(CANYON_FINAL_MIX1, MIXER(100,MIXER_PAN_LEFT))
! 	DISCRETE_OUTPUT(CANYON_FINAL_MIX2, MIXER(100,MIXER_PAN_RIGHT))
  DISCRETE_SOUND_END
  
  
*** raw/drivers/dragrace.c	Fri Jan 23 09:32:56 2004
--- src/drivers/dragrace.c	Tue Mar  9 01:52:38 2004
***************
*** 512,518 ****
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(593.8+581.6+1000.0+57.6))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(593.8+581.6+1000.0+57.6))
  
! 	DISCRETE_OUTPUT_STEREO(NODE_92, NODE_93, 100)
  DISCRETE_SOUND_END
  
  
--- 512,519 ----
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(593.8+581.6+1000.0+57.6))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(593.8+581.6+1000.0+57.6))
  
! 	DISCRETE_OUTPUT(NODE_92, MIXER(100,MIXER_PAN_LEFT))
! 	DISCRETE_OUTPUT(NODE_93, MIXER(100,MIXER_PAN_RIGHT))
  DISCRETE_SOUND_END
  
  
*** raw/drivers/orbit.c	Fri Jan 23 09:32:58 2004
--- src/drivers/orbit.c	Tue Mar  9 01:52:26 2004
***************
*** 409,415 ****
  	DISCRETE_ADDER3(NODE_91, 1, ORBIT_WARNING_SND, ORBIT_NOISE2_SND, ORBIT_ANOTE2_SND)
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(962.1+755.4+1000.0))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(962.1+755.4+1000.0))
! 	DISCRETE_OUTPUT_STEREO(NODE_93, NODE_92, 100)
  DISCRETE_SOUND_END
  
  
--- 409,416 ----
  	DISCRETE_ADDER3(NODE_91, 1, ORBIT_WARNING_SND, ORBIT_NOISE2_SND, ORBIT_ANOTE2_SND)
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(962.1+755.4+1000.0))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(962.1+755.4+1000.0))
! 	DISCRETE_OUTPUT(NODE_93, MIXER(100,MIXER_PAN_LEFT))
! 	DISCRETE_OUTPUT(NODE_92, MIXER(100,MIXER_PAN_RIGHT))
  DISCRETE_SOUND_END
  
  
*** raw/drivers/sprint2.c	Fri Jan 23 09:33:00 2004
--- src/drivers/sprint2.c	Tue Mar  9 01:52:06 2004
***************
*** 671,677 ****
  	DISCRETE_GAIN(SPRINT2_FINAL_MIX1, NODE_90, 65534.0/(846.9+1000.0+407.8))
  	DISCRETE_GAIN(SPRINT2_FINAL_MIX2, NODE_91, 65534.0/(846.9+1000.0+407.8))
  
! 	DISCRETE_OUTPUT_STEREO(SPRINT2_FINAL_MIX2, SPRINT2_FINAL_MIX1, 100)
  DISCRETE_SOUND_END
  
  static DISCRETE_SOUND_START(sprint1_sound_interface)
--- 671,678 ----
  	DISCRETE_GAIN(SPRINT2_FINAL_MIX1, NODE_90, 65534.0/(846.9+1000.0+407.8))
  	DISCRETE_GAIN(SPRINT2_FINAL_MIX2, NODE_91, 65534.0/(846.9+1000.0+407.8))
  
! 	DISCRETE_OUTPUT(SPRINT2_FINAL_MIX2, MIXER(100,MIXER_PAN_LEFT))
! 	DISCRETE_OUTPUT(SPRINT2_FINAL_MIX1, MIXER(100,MIXER_PAN_RIGHT))
  DISCRETE_SOUND_END
  
  static DISCRETE_SOUND_START(sprint1_sound_interface)
*** raw/drivers/subs.c	Fri Jan 23 09:33:00 2004
--- src/drivers/subs.c	Tue Mar  9 01:51:44 2004
***************
*** 293,299 ****
  	DISCRETE_ADDER4(NODE_91, 1, 0, SUBS_LAUNCH_SND, SUBS_CRASH_SND, SUBS_EXPLODE_SND)
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(320.8+77.5+149.2+1000.0))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(320.8+77.5+149.2+1000.0))
! 	DISCRETE_OUTPUT_STEREO(NODE_92, NODE_93, 100)
  DISCRETE_SOUND_END
  
  
--- 293,300 ----
  	DISCRETE_ADDER4(NODE_91, 1, 0, SUBS_LAUNCH_SND, SUBS_CRASH_SND, SUBS_EXPLODE_SND)
  	DISCRETE_GAIN(NODE_92, NODE_90, 65534.0/(320.8+77.5+149.2+1000.0))
  	DISCRETE_GAIN(NODE_93, NODE_91, 65534.0/(320.8+77.5+149.2+1000.0))
! 	DISCRETE_OUTPUT(NODE_92, MIXER(100,MIXER_PAN_LEFT))
! 	DISCRETE_OUTPUT(NODE_93, MIXER(100,MIXER_PAN_RIGHT))
  DISCRETE_SOUND_END
  
  
*** raw/sound/disc_mth.c	Sat Mar  6 15:45:26 2004
--- src/sound/disc_mth.c	Sun Mar  7 15:13:30 2004
***************
*** 22,27 ****
--- 22,28 ----
  /* DST_LOGIC_NOR         - Logic NOR gate 4 input                       */
  /* DST_LOGIC_XOR         - Logic XOR gate 2 input                       */
  /* DST_LOGIC_NXOR        - Logic NXOR gate 2 input                      */
+ /* DST_LOGIC_DFLIPFLOP   - Logic D-type flip/flop                       */
  /* DST_MIXER             - Final Mixer Stage                            */
  /* DST_ONESHOT           - One shot pulse generator                     */
  /* DST_RAMP              - Ramp up/down                                 */
***************
*** 86,91 ****
--- 87,97 ----
  	int clocktype;
  };
  
+ struct dst_dflipflop_context
+ {
+ 	int lastClk;
+ };
+ 
  /************************************************************************/
  /*                                                                      */
  /* DST_ADDER - This is a 4 channel input adder with enable function     */
***************
*** 1030,1035 ****
--- 1036,1103 ----
  
  /************************************************************************/
  /*                                                                      */
+ /* DST_LOGIC_DFF - Standard D-type flip-flop implementation             */
+ /*                                                                      */
+ /* input[0]    - /Reset                                                 */
+ /* input[1]    - /Set                                                   */
+ /* input[2]    - clock                                                  */
+ /* input[3]    - input                                                  */
+ /*                                                                      */
+ /************************************************************************/
+ int dst_logic_dff_step(struct node_description *node)
+ {
+ 	struct dst_dflipflop_context *context;
+ 	context=(struct dst_dflipflop_context*)node->context;
+ 
+ 	if (node->input[0])
+ 	{
+ 		if (!node->input[1])
+ 			node->output = 0;
+ 		else if (!node->input[2])
+ 			node->output = 1;
+ 		else if (!context->lastClk && node->input[3])
+ 			node->output = node->input[4];
+ 	}
+ 	else
+ 	{
+ 		node->output=0.0;
+ 	}
+ 	context->lastClk = node->input[3];
+ 	return 0;
+ }
+ 
+ int dst_logic_dff_reset(struct node_description *node)
+ {
+ 	struct dst_dflipflop_context *context;
+ 	context=(struct dst_dflipflop_context*)node->context;
+ 
+ 	context->lastClk = 0;
+ 	return 0;
+ }
+ 
+ int dst_logic_dff_init(struct node_description *node)
+ {
+ 	/* Allocate memory for the context array and the node execution order array */
+ 	if((node->context=malloc(sizeof(struct dst_dflipflop_context)))==NULL)
+ 	{
+ 		discrete_log("dss_logic_dff_init() - Failed to allocate local context memory.");
+ 		return 1;
+ 	}
+ 	else
+ 	{
+ 		/* Initialize memory */
+ 		memset(node->context,0,sizeof(struct dst_dflipflop_context));
+ 	}
+ 
+ 	/* Initialize the object */
+ 	dst_logic_dff_reset(node);
+ 	return 0;
+ }
+ 
+ 
+ 
+ /************************************************************************/
+ /*                                                                      */
  /* DST_COMP_ADDER  - Selectable parallel component adder                */
  /*                                                                      */
  /* input[0]    - Enable input value                                     */
*** raw/sound/disc_out.c	Thu May 15 04:59:00 2003
--- src/sound/disc_out.c	Tue Mar  9 01:54:10 2004
***************
*** 14,30 ****
  
  struct dso_output_context
  {
! 	INT16 left;
! 	INT16 right;
  };
  
  /************************************************************************/
  /*                                                                      */
  /* Usage of node_description values for step function                   */
  /*                                                                      */
! /* input[0]    - Left channel output value                              */
! /* input[1]    - Right channel output value                             */
! /* input[2]    - Volume setting (static)                                */
  /* input[3]    - NOT USED                                               */
  /* input[4]    - NOT USED                                               */
  /* input[5]    - NOT USED                                               */
--- 14,29 ----
  
  struct dso_output_context
  {
! 	INT16 output;
  };
  
  /************************************************************************/
  /*                                                                      */
  /* Usage of node_description values for step function                   */
  /*                                                                      */
! /* input[0]    - Output value                                           */
! /* input[1]    - Volume setting (static)                                */
! /* input[2]    - NOT USED                                               */
  /* input[3]    - NOT USED                                               */
  /* input[4]    - NOT USED                                               */
  /* input[5]    - NOT USED                                               */
***************
*** 36,43 ****
  	struct dso_output_context *context;
  	context=(struct dso_output_context*)node->context;
  	/* Clamp outputs */
! 	if(node->input[0]<-32768) context->left=-32768;  else if(node->input[0]>32767) context->left=32767;  else context->left=(INT16)node->input[0];
! 	if(node->input[1]<-32768) context->right=-32768; else if(node->input[1]>32767) context->right=32767; else context->right=(INT16)node->input[1];
  	return 0;
  }
  
--- 35,41 ----
  	struct dso_output_context *context;
  	context=(struct dso_output_context*)node->context;
  	/* Clamp outputs */
! 	if(node->input[0]<-32768) context->output=-32768;  else if(node->input[0]>32767) context->output=32767;  else context->output=(INT16)node->input[0];
  	return 0;
  }
  
*** raw/sound/discrete.c	Sat Mar  6 15:45:26 2004
--- src/sound/discrete.c	Tue Mar  9 22:18:58 2004
***************
*** 65,77 ****
  /*                                                                      */
  /************************************************************************/
  
! static int init_ok=0;
! static struct node_description **running_order=NULL;
! static int node_count=0;
! static struct node_description *node_list=NULL;
! static struct node_description *output_node=NULL;
! static int discrete_stream=0;
! static int discrete_stereo=0;
  
  /* Uncomment this line to log discrete sound output to a file */
  //#define DISCRETE_WAVELOG
--- 65,79 ----
  /*                                                                      */
  /************************************************************************/
  
! #define MAX_CHANNELS 16
! 
! static int init_ok;
! static struct node_description **running_order;
! static int node_count;
! static struct node_description *node_list;
! static struct node_description *output_node[MAX_CHANNELS];
! static int discrete_stream;
! static int discrete_channels;
  
  /* Uncomment this line to log discrete sound output to a file */
  //#define DISCRETE_WAVELOG
***************
*** 80,86 ****
  
  #ifdef DISCRETE_WAVELOG
  #include "wavwrite.h"
! static void *wav_file;
  #endif
  
  #ifdef DISCRETE_DEBUGLOG
--- 82,88 ----
  
  #ifdef DISCRETE_WAVELOG
  #include "wavwrite.h"
! static void *wav_file[MAX_CHANNELS];
  #endif
  
  #ifdef DISCRETE_DEBUGLOG
***************
*** 180,185 ****
--- 182,189 ----
  	{ DST_LOGIC_XOR   ,"DST_LOGIC_XOR"   ,NULL                 ,NULL                 ,NULL                  ,dst_logic_xor_step   },
  	{ DST_LOGIC_NXOR  ,"DST_LOGIC_NXOR"  ,NULL                 ,NULL                 ,NULL                  ,dst_logic_nxor_step  },
  
+ 	{ DST_LOGIC_DFF   ,"DST_LOGIC_DFF"   ,dst_logic_dff_init   ,dss_default_kill     ,dst_logic_dff_reset   ,dst_logic_dff_step   },
+ 
  	{ DSD_555_ASTBL   ,"DSD_555_ASTBL"   ,dsd_555_astbl_init   ,dss_default_kill     ,dsd_555_astbl_reset   ,dsd_555_astbl_step   },
  	{ DSD_555_CC      ,"DSD_555_CC"      ,dsd_555_cc_init      ,dss_default_kill     ,dsd_555_cc_reset      ,dsd_555_cc_step      },
  	{ DSD_566         ,"DSD_566"         ,dsd_566_init         ,dss_default_kill     ,dsd_566_reset         ,dsd_566_step         },
***************
*** 199,205 ****
  	return NULL;
  }
  
! static void discrete_stream_update_stereo(int ch, INT16 **buffer, int length)
  {
  	/* Now we must do length iterations of the node list, one output for each step */
  	int loop,loop2,loop3;
--- 203,209 ----
  	return NULL;
  }
  
! static void discrete_stream_update(int ch, INT16 **buffer, int length)
  {
  	/* Now we must do length iterations of the node list, one output for each step */
  	int loop,loop2,loop3;
***************
*** 223,266 ****
  		}
  
  		/* Now put the output into the buffers */
! 		buffer[0][loop]=((struct dso_output_context*)(output_node->context))->left;
! 		buffer[1][loop]=((struct dso_output_context*)(output_node->context))->right;
  	}
  #ifdef DISCRETE_WAVELOG
! 	wav_add_data_16lr(wav_file, buffer[0],buffer[1], length);
  #endif
  }
  
! static void discrete_stream_update_mono(int ch,INT16 *buffer, int length)
  {
! 	/* Now we must do length iterations of the node list, one output for each step */
! 	int loop,loop2,loop3;
! 	struct node_description *node;
! 
! 	for(loop=0;loop<length;loop++)
! 	{
! 		for(loop2=0;loop2<node_count;loop2++)
! 		{
! 			/* Pick the first node to process */
! 			node=running_order[loop2];
! 
! 			/* Work out what nodes/inputs are required, dont process NO CONNECT nodes */
! 			/* these are ones that are connected to NODE_LIST[0]                      */
! 			for(loop3=0;loop3<node->active_inputs;loop3++)
! 			{
! 				if(node->input_node[loop3] && (node->input_node[loop3])->node!=NODE_NC) node->input[loop3]=(node->input_node[loop3])->output;
! 			}
! 
! 			/* Now step the node */
! 			if(module_list[node->module].step) (*module_list[node->module].step)(node);
! 		}
! 
! 		/* Now put the output into the buffer */
! 		buffer[loop]=(((struct dso_output_context*)(output_node->context))->left+((struct dso_output_context*)(output_node->context))->right)/2;
! 	}
! #ifdef DISCRETE_WAVELOG
! 	wav_add_data_16(wav_file, buffer, length);
! #endif
  }
  
  void discrete_sh_reset(void)
--- 227,244 ----
  		}
  
  		/* Now put the output into the buffers */
! 		for (loop2 = 0; loop2 < discrete_channels; loop2++)
! 			buffer[loop2][loop] = ((struct dso_output_context*)(output_node[loop2]->context))->output;
  	}
  #ifdef DISCRETE_WAVELOG
! 	for (loop2 = 0; loop2 < discrete_channels; loop2++)
! 		wav_add_data_16(wav_file[loop2], buffer[loop2], length);
  #endif
  }
  
! static void discrete_stream_update_one(int ch, INT16 *buffer, int length)
  {
! 	discrete_stream_update(ch, &buffer, length);
  }
  
  void discrete_sh_reset(void)
***************
*** 302,316 ****
  
  int discrete_sh_start (const struct MachineSound *msound)
  {
  	struct discrete_sound_block *intf;
  	int loop=0,loop2=0,search=0,failed=0;
  
  	if (!Machine->sample_rate)
  		return 0;
  
- #ifdef DISCRETE_WAVELOG
- 	wav_file = wav_open("discrete.wav", Machine->sample_rate, ((Machine->drv->sound_attributes&SOUND_SUPPORTS_STEREO) == SOUND_SUPPORTS_STEREO) ? 2: 1);
- #endif
  #ifdef DISCRETE_DEBUGLOG
  	if(!disclogfile) disclogfile=fopen("discrete.log", "w");
  #endif
--- 280,294 ----
  
  int discrete_sh_start (const struct MachineSound *msound)
  {
+ 	const char *channel_names[MAX_CHANNELS];
+ 	char channel_name_data[MAX_CHANNELS][32];
+ 	int channel_vol[MAX_CHANNELS];
  	struct discrete_sound_block *intf;
  	int loop=0,loop2=0,search=0,failed=0;
  
  	if (!Machine->sample_rate)
  		return 0;
  
  #ifdef DISCRETE_DEBUGLOG
  	if(!disclogfile) disclogfile=fopen("discrete.log", "w");
  #endif
***************
*** 406,412 ****
  	{
  		for(loop2=0;loop2<node_count;loop2++)
  		{
! 			if(node_list[loop].node==node_list[loop2].node && loop!=loop2)
  			{
  				logerror("discrete_sh_start - Node NODE_%02d defined more than once\n",node_list[loop].node-NODE_00);
  				failed=1;
--- 384,390 ----
  	{
  		for(loop2=0;loop2<node_count;loop2++)
  		{
! 			if(node_list[loop].node==node_list[loop2].node && loop!=loop2 && node_list[loop].node!=NODE_OP)
  			{
  				logerror("discrete_sh_start - Node NODE_%02d defined more than once\n",node_list[loop].node-NODE_00);
  				failed=1;
***************
*** 464,471 ****
  			search++;
  		}
  	}
! 	/* Setup the output node */
! 	if((output_node=discrete_find_node(NODE_OP))==NULL)
  	{
  		logerror("discrete_sh_start() - Couldn't find an output node");
  		failed=1;
--- 442,469 ----
  			search++;
  		}
  	}
! 	
! 	/* Setup the output nodes */
! 	discrete_channels = 0;
! 	for (loop = 0; loop < node_count; loop++)
! 		if (node_list[loop].node == NODE_OP)
! 		{
! 			sprintf(&channel_name_data[discrete_channels][0], "Discrete CH%d", discrete_channels);
! 			channel_vol[discrete_channels] = node_list[loop].input[1];
! 			output_node[discrete_channels] = &node_list[loop];
! 			channel_names[discrete_channels] = &channel_name_data[discrete_channels][0];
! 
! #ifdef DISCRETE_WAVELOG
! 			{
! 				char name[32];
! 				sprintf(name, "discrete%d.wav", discrete_channels);
! 				wav_file[discrete_channels] = wav_open(name, Machine->sample_rate, 1);
! 			}
! #endif
! 
! 			discrete_channels++;
! 		}
! 	if (discrete_channels == 0)
  	{
  		logerror("discrete_sh_start() - Couldn't find an output node");
  		failed=1;
***************
*** 473,499 ****
  
  	discrete_log("discrete_sh_start() - Nodes initialised", node_count);
  
! 	/* Different setup for Mono/Stereo systems */
! 	if ((Machine->drv->sound_attributes&SOUND_SUPPORTS_STEREO) == SOUND_SUPPORTS_STEREO)
! 	{
! 		int vol[2];
! 		const char *stereo_names[2] = { "Discrete Left", "Discrete Right" };
! 		vol[0] = MIXER((int)output_node->input[2],MIXER_PAN_LEFT);
! 		vol[1] = MIXER((int)output_node->input[2],MIXER_PAN_RIGHT);
! 		/* Initialise a stereo, stream, we always use stereo even if only a mono system */
! 		discrete_stream=stream_init_multi(2,stereo_names,vol,Machine->sample_rate,0,discrete_stream_update_stereo);
! 		discrete_log("discrete_sh_start() - Stereo Audio Stream Initialised", node_count);
! 		discrete_stereo=1;
! 	}
  	else
! 	{
! 		int vol;
! 		vol = output_node->input[2];
! 		/* Initialise a stereo, stream, we always use stereo even if only a mono system */
! 		discrete_stream=stream_init("Discrete Sound",vol,Machine->sample_rate,0,discrete_stream_update_mono);
! 		discrete_log("discrete_sh_start() - Mono Audio Stream Initialised", node_count);
! 	}
! 
  	if(discrete_stream==-1)
  	{
  		logerror("discrete_sh_start - Stream init returned an error\n");
--- 471,482 ----
  
  	discrete_log("discrete_sh_start() - Nodes initialised", node_count);
  
! 	/* Build up the stream definitions */
! 	if (discrete_channels > 1)
! 		discrete_stream = stream_init_multi(discrete_channels, channel_names, channel_vol, Machine->sample_rate, 0, discrete_stream_update);
  	else
! 		discrete_stream = stream_init(channel_names[0], channel_vol[0], Machine->sample_rate, 0, discrete_stream_update_one);
! 	discrete_log("discrete_sh_start() - Audio Stream Initialised", node_count);
  	if(discrete_stream==-1)
  	{
  		logerror("discrete_sh_start - Stream init returned an error\n");
***************
*** 516,522 ****
  	if(!init_ok) return;
  
  #ifdef DISCRETE_WAVELOG
! 	wav_close(wav_file);
  #endif
  
  	for(loop=0;loop<node_count;loop++)
--- 499,506 ----
  	if(!init_ok) return;
  
  #ifdef DISCRETE_WAVELOG
! 	for (loop = 0; loop < discrete_channels; loop++)
! 		wav_close(wav_file[loop]);
  #endif
  
  	for(loop=0;loop<node_count;loop++)
*** raw/sound/discrete.h	Sat Mar  6 15:45:26 2004
--- src/sound/discrete.h	Tue Mar  9 01:57:18 2004
***************
*** 171,176 ****
--- 171,177 ----
  /* DISCRETE_LOGIC_NOR4(NODE,ENAB,INP0,INP1,INP2,INP3)                   */
  /* DISCRETE_LOGIC_XOR(NODE,ENAB,INP0,INP1)                              */
  /* DISCRETE_LOGIC_NXOR(NODE,ENAB,INP0,INP1)                             */
+ /* DISCRETE_LOGIC_DFLIPFLOP(NODE,RESET,SET,CLK,INP)                     */
  /*                                                                      */
  /* DISCRETE_555_ASTABLE(NODE,RESET,AMPL,R1,R2,C,CTRLV,TYPE)             */
  /* DISCRETE_555_CC(NODE,RESET,VIN,R,C,RBIAS,RGND,RDIS,OPTIONS)          */
***************
*** 1160,1165 ****
--- 1161,1200 ----
  /*                                                                      */
  /************************************************************************/
  /*                                                                      */
+ /* DISCRETE_LOGIC_DFLIPFLOP - Standard D-type flip-flop                 */
+ /*                                                                      */
+ /*    /SET       -2-------------+                                       */
+ /*                              v                                       */
+ /*                        .-----o------.                                */
+ /*                        |            |                                */
+ /*    INPUT      -4------>|            |                                */
+ /*                        |            |                                */
+ /*                        |  FLIPFLOP  |---->    Netlist node           */
+ /*                        |            |                                */
+ /*    CLOCK      -3------>|            |                                */
+ /*                        |            |                                */
+ /*                        '-----o------'                                */
+ /*                              ^                                       */
+ /*    /RESET     -1-------------+                                       */
+ /*                                                                      */
+ /*  Declaration syntax                                                  */
+ /*                                                                      */
+ /*       DISCRETE_LOGIC_DFLIPFLOP(name of node,                         */
+ /*                                enable,                               */
+ /*                                reset node or static value,           */
+ /*                                set node or static value,             */
+ /*                                clock node,                           */
+ /*                                input node or static value)           */
+ /*                                                                      */
+ /*  Example config line                                                 */
+ /*                                                                      */
+ /*     DISCRETE_LOGIC_DFLIPFLOP(NODE_7,1,NODE_17,0,NODE_13,1)           */
+ /*                                                                      */
+ /*  A flip-flop that clocks a logic 1 through on the rising edge of     */
+ /*  NODE_13. A logic 1 on NODE_17 resets the output to 0.               */
+ /*                                                                      */
+ /************************************************************************/
+ /*                                                                      */
  /* DISCRETE_LADDER - Resistor ladder D/A with smoothing R/C             */
  /*                                                                      */
  /*                        .------------.                                */
***************
*** 1860,1865 ****
--- 1895,1902 ----
  	DST_LOGIC_XOR,
  	DST_LOGIC_NXOR,
  
+ 	DST_LOGIC_DFF,
+ 
  	/* Devices */
  	DSD_555_ASTBL,		/* NE555 Astable Emulation */
  	DSD_555_CC,		/* Constant Current 555 circuit (VCO)*/
***************
*** 1957,1969 ****
  #define DISCRETE_LOGIC_NOR4(NODE,ENAB,INP0,INP1,INP2,INP3)              { NODE, DST_LOGIC_NOR   , 5, { ENAB,INP0,INP1,INP2,INP3 }, { ENAB,INP0,INP1,INP2,INP3 }, NULL, "Logic NOR (4inp)" },
  #define DISCRETE_LOGIC_XOR(NODE,ENAB,INP0,INP1)                         { NODE, DST_LOGIC_XOR   , 3, { ENAB,INP0,INP1 }, { ENAB,INP0,INP1 }, NULL, "Logic XOR (2inp)" },
  #define DISCRETE_LOGIC_NXOR(NODE,ENAB,INP0,INP1)                        { NODE, DST_LOGIC_NXOR  , 3, { ENAB,INP0,INP1 }, { ENAB,INP0,INP1 }, NULL, "Logic NXOR (2inp)" },
  
  #define DISCRETE_555_ASTABLE(NODE,RESET,R1,R2,C,CTRLV,OPTIONS)          { NODE, DSD_555_ASTBL   , 5, { RESET,R1,R2,C,CTRLV }, { RESET,R1,R2,C,CTRLV }, OPTIONS, "555 Astable" },
  #define DISCRETE_555_CC(NODE,RESET,VIN,R,C,RBIAS,RGND,RDIS,OPTIONS)     { NODE, DSD_555_CC      , 7, { RESET,VIN,R,C,RBIAS,RGND,RDIS }, { RESET,VIN,R,C,RBIAS,RGND,RDIS }, OPTIONS, "555 Constant Current VCO" },
  #define DISCRETE_566(NODE,ENAB,VMOD,R,C,OPTIONS)                        { NODE, DSD_566         , 4, { ENAB,VMOD,R,C }, { ENAB,VMOD,R,C }, OPTIONS, "566" },
  
! #define DISCRETE_OUTPUT(OPNODE,VOL)                                     { NODE_OP, DSO_OUTPUT   , 3, { OPNODE,OPNODE,NODE_NC }, {0,0,VOL }, NULL, "Output Node" },
! #define DISCRETE_OUTPUT_STEREO(OPNODEL,OPNODER,VOL)                     { NODE_OP, DSO_OUTPUT   , 3, { OPNODEL,OPNODER,NODE_NC }, { 0,0,VOL }, NULL, "Stereo Output Node" },
  
  
  /************************************************************************/
--- 1994,2006 ----
  #define DISCRETE_LOGIC_NOR4(NODE,ENAB,INP0,INP1,INP2,INP3)              { NODE, DST_LOGIC_NOR   , 5, { ENAB,INP0,INP1,INP2,INP3 }, { ENAB,INP0,INP1,INP2,INP3 }, NULL, "Logic NOR (4inp)" },
  #define DISCRETE_LOGIC_XOR(NODE,ENAB,INP0,INP1)                         { NODE, DST_LOGIC_XOR   , 3, { ENAB,INP0,INP1 }, { ENAB,INP0,INP1 }, NULL, "Logic XOR (2inp)" },
  #define DISCRETE_LOGIC_NXOR(NODE,ENAB,INP0,INP1)                        { NODE, DST_LOGIC_NXOR  , 3, { ENAB,INP0,INP1 }, { ENAB,INP0,INP1 }, NULL, "Logic NXOR (2inp)" },
+ #define DISCRETE_LOGIC_DFLIPFLOP(NODE,ENAB,RESET,SET,CLK,INP)           { NODE, DST_LOGIC_DFF   , 5, { ENAB,RESET,SET,CLK,INP }, { ENAB,RESET,SET,CLK,INP }, NULL, "Logic DFlipFlop" },
  
  #define DISCRETE_555_ASTABLE(NODE,RESET,R1,R2,C,CTRLV,OPTIONS)          { NODE, DSD_555_ASTBL   , 5, { RESET,R1,R2,C,CTRLV }, { RESET,R1,R2,C,CTRLV }, OPTIONS, "555 Astable" },
  #define DISCRETE_555_CC(NODE,RESET,VIN,R,C,RBIAS,RGND,RDIS,OPTIONS)     { NODE, DSD_555_CC      , 7, { RESET,VIN,R,C,RBIAS,RGND,RDIS }, { RESET,VIN,R,C,RBIAS,RGND,RDIS }, OPTIONS, "555 Constant Current VCO" },
  #define DISCRETE_566(NODE,ENAB,VMOD,R,C,OPTIONS)                        { NODE, DSD_566         , 4, { ENAB,VMOD,R,C }, { ENAB,VMOD,R,C }, OPTIONS, "566" },
  
! #define DISCRETE_OUTPUT(OPNODE,VOL)                                     { NODE_OP, DSO_OUTPUT   , 2, { OPNODE,NODE_NC }, {0,VOL }, NULL, "Output Node" },
  
  
  /************************************************************************/
*** raw/mame.mak	Sat Mar  6 15:45:26 2004
--- src/mame.mak	Sun Mar  7 20:36:38 2004
***************
*** 994,1000 ****
  	$(OBJ)/machine/pgmprot.o $(OBJ)/machine/pgmcrypt.o \
  
  $(OBJ)/ramtek.a: \
! 	$(OBJ)/vidhrdw/hitme.o $(OBJ)/drivers/hitme.o \
  	$(OBJ)/vidhrdw/starcrus.o $(OBJ)/drivers/starcrus.o \
  
  $(OBJ)/omori.a: \
--- 997,1003 ----
  	$(OBJ)/machine/pgmprot.o $(OBJ)/machine/pgmcrypt.o \
  
  $(OBJ)/ramtek.a: \
! 	$(OBJ)/drivers/hitme.o \
  	$(OBJ)/vidhrdw/starcrus.o $(OBJ)/drivers/starcrus.o \
  
  $(OBJ)/omori.a: \
